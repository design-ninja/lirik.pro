---
import { type CollectionEntry, getCollection } from 'astro:content';
import BaseLayout from '../../layouts/BaseLayout.astro';
import FormattedDate from '../../components/Blog/FormattedDate.astro';
import PostPreview from '../../components/Blog/PostPreview.astro';
import { sortItemsByDateDesc } from '../../utils/data-utils';
export const prerender = true;
import { slugify } from '../../utils/common-utils';

export async function getStaticPaths() {
  const posts = (await getCollection('blog')).sort(sortItemsByDateDesc);
  const postCount = posts.length;
  return posts.map((post, index) => ({
    params: { slug: post.slug },
    props: {
      post,
      prevPost: index + 1 !== postCount ? posts[index + 1] : null,
      nextPost: index !== 0 ? posts[index - 1] : null
    }
  }));
}

type Props = { post: CollectionEntry<'blog'>; prevPost: CollectionEntry<'blog'>; nextPost: CollectionEntry<'blog'> };

let post: CollectionEntry<'blog'> | undefined = Astro.props?.post as Props['post'] | undefined;
let prevPost: CollectionEntry<'blog'> | null | undefined = (Astro.props as Props | undefined)?.prevPost ?? undefined;
let nextPost: CollectionEntry<'blog'> | null | undefined = (Astro.props as Props | undefined)?.nextPost ?? undefined;

// Fallback for SSR or when a path wasn't provided via getStaticPaths props
if (!post) {
  const { slug } = Astro.params;
  const posts = (await getCollection('blog')).sort(sortItemsByDateDesc);
  const index = posts.findIndex((p) => p.slug === slug);
  if (index !== -1) {
    post = posts[index];
    prevPost = index + 1 !== posts.length ? posts[index + 1] : null;
    nextPost = index !== 0 ? posts[index - 1] : null;
  }
}

if (!post) {
  Astro.response.status = 404;
  throw new Error('Post not found');
}

const { title, publishDate, updatedDate, tags = [], seo } = post.data;
const { Content } = await post.render();

function getFirstParagraphFromMarkdown(markdown: string) {
  if (!markdown) return '';
  const firstBlock = markdown.trim().split(/\n\s*\n/)[0] || '';
  const withoutImages = firstBlock.replace(/!\[[^\]]*\]\([^)]*\)/g, '');
  const withoutLinks = withoutImages.replace(/\[([^\]]+)\]\([^)]*\)/g, '$1');
  const withoutFormatting = withoutLinks.replace(/[\\*_`~>]/g, '');
  return withoutFormatting.trim();
}
const firstParagraph = getFirstParagraphFromMarkdown(post.body);
---

<BaseLayout title={seo?.title ?? title} description={seo?.description ?? firstParagraph} image={seo?.image} pageType="article">
  <article class="Article">
    <header>
      <h1>{title}</h1>
    </header>
    <div>
      <Content />
      <div class="Article__Footer">
        <div>
          <FormattedDate date={publishDate} />
          {
            updatedDate && (
              <>
                {' '}
                <span>
                  (Обновлено: <FormattedDate date={updatedDate} />)
                </span>
              </>
            )
          }
        </div>
        <div class="Article__Tags">
          {
            tags.length > 0 && (
              <div class="Article__TagsList">
                {tags.map((tag) => (
                  <a href={`/tags/${slugify(tag)}`}>#{tag}</a>
                ))}
              </div>
            )
          }
        </div>
      </div>
    </div>
    {
      (prevPost || nextPost) && (
        <div>
          <h3>Еще в Блоге</h3>
          {nextPost && <PostPreview post={nextPost} headingLevel="h3" />}
          {prevPost && <PostPreview post={prevPost} headingLevel="h3" />}
        </div>
      )
    }
  </article>
</BaseLayout>

<script>
  document.addEventListener('astro:page-load', () => {
    const copyUrlButton = document.querySelector('.copy-url-button') as HTMLButtonElement;
    copyUrlButton?.addEventListener('click', async () => {
      await copyUrl(copyUrlButton);
    });

    async function copyUrl(button: HTMLButtonElement) {
      let url = button.getAttribute('data-url') || '';
      let label = button.innerText;

      await navigator.clipboard.writeText(url);

      button.innerText = 'Copied';

      setTimeout(() => {
        button.innerText = label;
      }, 2500);
    }
  });
</script>

<style lang="scss">
  .Article {
    display: grid;
    gap: var(--space-40);
    margin: 0 auto;
    max-width: 900px;

    &__TagsList {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-8);
      font-size: var(--font-size-14);
    }

    &__Footer {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: var(--space-8);
      margin-top: var(--space-24);
    }

    &__Nav {
      display: flex;
      gap: var(--space-24);
      justify-content: space-between;
      align-items: start;
      text-decoration: none;
      padding-top: var(--space-24);
      border-top: 1px solid var(--color-border-primary);

      &Item {
        display: inline-grid;
        gap: var(--space-24);

        &:last-child {
          text-align: right;
        }
      }
    }
  }
</style>
